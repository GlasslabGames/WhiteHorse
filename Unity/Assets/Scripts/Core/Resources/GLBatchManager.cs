//
// GLBatchManager.cs
// Author: Jerry Fu <jerry@glasslabgames.org>
// 2014 - 8 - 5
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Collections;

namespace GlassLab.Batch
{
  public class GLBatchManager : SingletonBehavior<GLBatchManager>
  {
    private Dictionary<string, BatchJob> m_jobs = new Dictionary<string, BatchJob>(); // Dictionary sorted by name of job => m_jobs[key] = BatchJob

    private Queue<BatchJob> m_executionQueue = new Queue<BatchJob>();
    private bool m_executing = false;
    protected GLBatchManager() {}

    private float m_updateTime;

    override protected void Awake()
    {
        base.Awake();
      StartCoroutine(updateLoop());
    }

    void FixedUpdate()
    {
      m_updateTime = Time.realtimeSinceStartup;
    }

    public bool IsBusy { get { return m_executionQueue.Count > 0; } }

    private WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();
    private IEnumerator updateLoop()
    {
      m_executing = true;

      while(m_executionQueue.Count > 0)
      {
        yield return waitForEndOfFrame;
        float timeRemaining = .033f - (Time.realtimeSinceStartup - m_updateTime); // .033f = 33 ms = 30 FPS
        float startTime = Time.realtimeSinceStartup;

        while (Time.realtimeSinceStartup - startTime < timeRemaining - .01f &&
               m_executionQueue.Count > 0)
        {
          doNextJob();
        }
      }

      m_executing = false;
    }

    private void doNextJob()
    {
      BatchJob job = m_executionQueue.Dequeue();

      if (!job.IsComplete)
      {
        job.Do();
        m_jobs.Remove(job.Name);
      }
    }

    public bool HasJob(string name)
    {
      return m_jobs.ContainsKey(name);
    }

    public BatchJob AddJob(Action jobFunction, string name)
    {
      BatchJob job = new BatchJob(jobFunction, name);
      return AddJob(job);
    }

    public BatchJob AddJob(BatchJob job)
    {
      if (m_executionQueue.Count == 0)
      {
        if (m_executing)
        {
          Debug.LogError("Execution loop was already running when attempting to start", this);
        }
        else
        {
          StartCoroutine(updateLoop());
        }
      }

      job.IsComplete = false;
      m_executionQueue.Enqueue(job);

      if (!m_jobs.ContainsKey(job.Name))
      {
        m_jobs[job.Name] = job;
      }
      else
      {
        //throw new Exception("Tried to start a job with a name that already exists, Name:"+job.Name);
        Debug.LogError("Tried to start a job with a name that already exists, Name:"+job.Name);
      }

      return job;
    }

    public void ForceComplete(BatchJob job)
    {
      job.Do();
      m_jobs.Remove(job.Name);
    }

    public void ForceComplete(string name)
    {
      ForceComplete(m_jobs[name]);
    }
  }
}
