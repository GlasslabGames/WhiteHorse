//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using HutongGames.PlayMaker;
using HutongGames.Utility;
using PixelCrushers.DialogueSystem;

[RequireComponent(typeof(PlayMakerFSM))]
public class Quest : MonoBehaviour
{
  public const string QUEST_START_EVENT = "ACTIVATE"; // This is the event that is sent when a quest is started
  public const string QUEST_CANCEL_EVENT = "RESET"; // This is the event that is sent when a quest is canceled
  public const string QUEST_WAITING_STATE = "Init"; // This is what the state name should be when a quest is available
  public event QuestEvent QuestCompleted; // Event defined in SignalManager

  public string Title = "<QuestTitle>";
  public string Description = "<QuestDescription>";

  private Objective[] m_objectives;
  private PlayMakerFSM m_fsm;
  public string CompleteFSMEvent;
  public const string QUEST_COMPLETE_EVENT = "QUEST_COMPLETED"; // This event is broadcasted to all FSMs

  public const string BETWEEN_QUEST_DIALOGUE = "BetweenQuests"; // set lua progress to this betweeen quests

  [PersistAttribute]
  private bool m_isComplete = false;

  private QuestState m_currentState = QuestState.UNINITIALIZED;

  public bool IsSideQuest = false;
  public bool IsCancelable = true;

  public bool IsComplete { get { return m_isComplete; } }

  void Awake()
  {
    m_fsm = GetComponent<PlayMakerFSM>();
    if(!m_fsm)
    {
      Debug.LogError("Quest could not find FSM!", this);
      enabled = false;
    }

    // Find all child objectives
    m_objectives = GetComponentsInChildren<Objective>(true);

    // Register event listeners on all child objectives
    foreach(Objective o in m_objectives)
    {
      o.ObjectiveCompleted += onObjectiveComplete;
    }

    refreshQuestState();
  }

  // Same as activating the game object, but checks if the quest is complete already
  public void Activate() {
    List<string> completedQuests = QuestManager.InstanceOrCreate.GetCompletedQuests();
    Debug.Log ("[Quest] Trying to activate "+name+". IsComplete? "+m_isComplete+" CompletedQuests? "+(completedQuests.IndexOf(name) > -1));
    if (completedQuests.IndexOf(name) == -1) gameObject.SetActive(true); // not yet completed
    else Debug.Log("[Quest] Can't activated "+name+" because it's already complete."); 
  }

  /**
   * Triggers an event in the quest FSM
   */
  public void Trigger(string transitionName)
  {
    m_fsm.SendEvent(transitionName);
  }

  [ContextMenu ("Cancel Quest")]
  public void Cancel()
  {
    // Be careful, the order here matters. First we send the reset event, so the FSM goes back to Init
    m_fsm.SendEvent(QUEST_CANCEL_EVENT);

    refreshQuestState();

    if (SignalManager.QuestCanceled != null)
    {
      SignalManager.QuestCanceled(this);
    }
    if (SignalManager.QuestChanged != null) SignalManager.QuestChanged(this); // call QuestChanged whenever anything changes

    EquipmentManager.InstanceOrCreate.ResetInventory();

    foreach (Objective o in m_objectives) {
      o.Reset();
      o.gameObject.SetActive(false);
    }

    Lua.Run("Variable['Progress']='"+BETWEEN_QUEST_DIALOGUE+"'");

    PegasusManager.Instance.GLSDK.AddTelemEventValue( "questId", name );
    PegasusManager.Instance.GLSDK.AddTelemEventValue( "questName", Title );
    PegasusManager.Instance.AppendDefaultTelemetryInfo();
    PegasusManager.Instance.GLSDK.SaveTelemEvent( "Quest_cancel" );
  }

  private void refreshQuestState()
  {
    QuestState prevState = m_currentState;
    m_currentState = CalculateQuestState();
    if(prevState != m_currentState)
    {
      if(SignalManager.QuestStateChanged != null)
      {
        SignalManager.QuestStateChanged(this);
      }
    }
  }

  void OnEnable()
  {
    refreshQuestState();
  }

  void OnDisable()
  {
    refreshQuestState();
  }

  // TODO: Is this necessary, or does isAvailableForStart() already take care of this?
  public bool IsAvailable()
  {
    //Debug.Log ("Quest "+this+" is available? "+m_currentState);
    return CalculateQuestState() == QuestState.AVAILABLE;
  }

  public QuestState CalculateQuestState()
  {
    if(m_isComplete)
    {
      return QuestState.COMPLETE;
    }

    if(!gameObject.activeSelf)
    {
      return QuestState.UNAVAILABLE;
    }

    if(isAvailableForStart())
    {
      return QuestState.AVAILABLE;
    }
    else
    {
      return QuestState.ACTIVE;
    }
  }

  public List<Objective> GetActiveObjectives()
  {
    List<Objective> returnArray = new List<Objective>();

    // TODO: Race condition where this can happen in OnEnable in other components before Awake() happens here
    
    if (m_objectives == null) m_objectives = GetComponentsInChildren<Objective>(true);
    foreach(Objective o in m_objectives)
    {
      if(o.gameObject.activeInHierarchy && !o.IsComplete())
      {
        returnArray.Add(o);
      }
    }

    return returnArray;
  }

  public List<Objective> GetObjectives()
  {
    return new List<Objective>(m_objectives);
  }
  
  void OnDestroy()
  {
    // Stop listening for child objective changes
    foreach(Objective o in m_objectives)
    {
      o.ObjectiveCompleted -= onObjectiveComplete;
    }
  }

  public string GetCheckpointEventString()
  {
    string checkpointEventName = getCurrentFSMState().Description;
    return checkpointEventName;
  }

  public string GetTitle()
  {
    return Title;
  }

  public string GetDescription()
  {
    return Description;
  }

  private FsmState getCurrentFSMState()
  {
    string currentStateName = m_fsm.ActiveStateName;
    foreach(FsmState state in m_fsm.FsmStates)
    {
      if(state.Name == currentStateName)
      {
        return state;
      }
    }

    return null;
  }

  private bool isAvailableForStart()
  {
    return m_fsm.ActiveStateName == QUEST_WAITING_STATE;
  }

  [ContextMenu ("Start Quest")]
  public void StartQuestShortcut() {
    // Now you can start quests from the inspector! It didn't seem to like the optional parameter so I added this shortcut.
    StartQuest(QUEST_START_EVENT);
  }

  public void StartQuest(string startState = QUEST_START_EVENT)
  {
    if(!gameObject.activeSelf)
    {
      gameObject.SetActive(true);
    }

    if(m_fsm == null)
    {
      m_fsm = GetComponent<PlayMakerFSM>();
    }

    // Cancel any previous quests
    Quest currentActiveQuest = QuestManager.Instance.GetCurrentActiveQuest();
    if (currentActiveQuest != null)
    {
      if (currentActiveQuest != this)
      {
        Debug.LogError("[Quest] Activating an already active quest again!", this);
      }
      else
      {
        currentActiveQuest.Cancel();
      }
    }

    if(isAvailableForStart())
    {
      m_fsm.SendEvent(startState);
      if(SignalManager.QuestStarted != null)
      {
        SignalManager.QuestStarted(this);
      }
      if (SignalManager.QuestChanged != null) SignalManager.QuestChanged(this); // call QuestChanged whenever anything changes

			// Only start the quest if this is a quest start event
			// This avoids complications with starting quests loaded from a save state
			if( startState == QUEST_START_EVENT ) {
				// End the interstitial game session
				//PegasusManager.Instance.EndSession();
				// Start a new quest game session
				//PegasusManager.Instance.StartSession();

        // Reset the activity attempts
        if (ActivityStatsManager.Instance != null) {
          ActivityStatsManager.Instance.ResetActivityAttempts();
        }
			}

      PegasusManager.Instance.GLSDK.AddTelemEventValue( "questId", name );
      PegasusManager.Instance.GLSDK.AddTelemEventValue( "questName", Title );
      PegasusManager.Instance.AppendDefaultTelemetryInfo();
      PegasusManager.Instance.GLSDK.SaveTelemEvent( "Quest_start" );
    }
    else
    {
      Debug.LogWarning("[Quest (" + name + ")] Tried to start when quest is already started", this);
    }
    
    refreshQuestState();
  }

  private void onObjectiveComplete(Objective o)
  {
    // Check if objective is related to this quest
    // TODO: Shouldn't need to do this, only quest that needs to know should receive this event
    if(m_objectives.Contains<Objective>(o))
    {
      foreach(Objective objective in m_objectives)
      {
        if(!objective.IsComplete())
        {
          return;
        }
      }

      onAllObjectivesComplete();
    }
  }

  [ContextMenu ("Complete Quest")]
  public void CompleteQuest()
  {
    if(!m_isComplete)
    {
      m_isComplete = true;
    
      EquipmentManager.InstanceOrCreate.ResetInventory();
      refreshQuestState();
      gameObject.SetActive(false);

      if(SignalManager.QuestCompleted != null)
      {
        SignalManager.QuestCompleted(this);
      }
      if (SignalManager.QuestChanged != null) SignalManager.QuestChanged(this); // call QuestChanged whenever anything changes

      if(QuestCompleted != null)
      {
        QuestCompleted(this);
      }

      Lua.Run("Variable['progress']='"+BETWEEN_QUEST_DIALOGUE+"'");

			Debug.Log ( "//////// End Quest ////////" );
      PegasusManager.Instance.GLSDK.AddTelemEventValue( "questId", name );
      PegasusManager.Instance.GLSDK.AddTelemEventValue( "questName", Title );
      PegasusManager.Instance.AppendDefaultTelemetryInfo();
      PegasusManager.Instance.GLSDK.SaveTelemEvent( "Quest_complete" );
    }
    else
    {
      Debug.LogWarning("Tried to complete a quest when it was already completed", this);
    }
  }

  private void onAllObjectivesComplete()
  {
    // CompleteQuest();
  }

  public float GetProgress()
  {
    // this is a pretty hacky way to do it
//    ObtainAllEvidenceObjective objective = GetComponentInChildren<ObtainAllEvidenceObjective>();
//    float progress = .5f;
//
//    if (objective != null)
//    {
//      progress = objective.GetProgress();
//    }
    /*
    float totalObjectives = (float) m_objectives.Length;
    foreach(Objective o in m_objectives)
    {
      progress += o.GetProgress() / totalObjectives;
    }
    */
    float progress = .0f;
    Objective[] objectives = GetComponentsInChildren<Objective>(true);
    if (objectives != null && objectives.Length > 0)
    {
      float total = objectives.Length;
      float finished = 0f;
      foreach (var o in objectives)
      {
        if (o.IsComplete())
          finished++;
      }
      progress = finished / total;
    }
    return Mathf.Round(progress * 1000f) / 1000f; // Round to 3 decimal places
  }

  public void Refresh()
  {
    foreach(Objective objective in m_objectives)
    {
      objective.Refresh();
    }

    refreshQuestState();
  }
}

